# UML Diagram of simulator



The UML diagram shows the KPUSimulator class architecture with its key characteristics:



**Main Components:**

- **KPUSimulator** - The central orchestrator class that manages all hardware components

- **Memory hierarchy** - MemoryBank (external), L3Tile, L2Bank, and Scratchpad

- **Data movement engines** - DMAEngine (memory↔scratchpad) and BlockMover (L3↔L2)

- **Compute resources** - ComputeTile for matrix multiplications



**Key Design Patterns:**

- **Composition** - KPUSimulator contains vectors of all component types

- **Delegation** - Clean API that delegates operations to appropriate components

- **Configuration-driven** - Constructor takes a Config object to set up all resources

- **Callback-based async operations** - DMA transfers and compute operations use callbacks



**Notable C++ idioms used:**

- RAII through proper constructor initialization with `reserve()` and `emplace_back()`

- Exception safety with validation methods throwing `std::out_of_range`

- Move semantics for callbacks (`std::move(callback)`)

- Modern range-based loops in `step()` and status checking

- Proper const-correctness on query methods

The simulator provides both low-level component access and high-level test operations, making it suitable for both detailed hardware modeling and system-level validation.

```mermaid

classDiagram
    class KPUSimulator {
        -current_cycle: uint64_t
        -memory_banks: vector~MemoryBank~
        -scratchpads: vector~Scratchpad~
        -compute_tiles: vector~ComputeTile~
        -dma_engines: vector~DMAEngine~
        -l3_tiles: vector~L3Tile~
        -l2_banks: vector~L2Bank~
        -block_movers: vector~BlockMover~
        -sim_start_time: chrono::time_point
        
        +KPUSimulator(config: Config)
        +read_memory_bank(bank_id: size_t, addr: Address, data: void*, size: Size): void
        +write_memory_bank(bank_id: size_t, addr: Address, data: void*, size: Size): void
        +read_scratchpad(pad_id: size_t, addr: Address, data: void*, size: Size): void
        +write_scratchpad(pad_id: size_t, addr: Address, data: void*, size: Size): void
        +read_l3_tile(tile_id: size_t, addr: Address, data: void*, size: Size): void
        +write_l3_tile(tile_id: size_t, addr: Address, data: void*, size: Size): void
        +read_l2_bank(bank_id: size_t, addr: Address, data: void*, size: Size): void
        +write_l2_bank(bank_id: size_t, addr: Address, data: void*, size: Size): void
        +start_dma_transfer(dma_id: size_t, src_type: MemoryType, ...): void
        +start_dma_external_to_scratchpad(...): void
        +start_dma_scratchpad_to_external(...): void
        +is_dma_busy(dma_id: size_t): bool
        +start_block_transfer(block_mover_id: size_t, ...): void
        +is_block_mover_busy(block_mover_id: size_t): bool
        +start_matmul(tile_id: size_t, ...): void
        +is_compute_busy(tile_id: size_t): bool
        +reset(): void
        +step(): void
        +run_until_idle(): void
        +get_memory_bank_capacity(bank_id: size_t): Size
        +get_scratchpad_capacity(pad_id: size_t): Size
        +get_l3_tile_capacity(tile_id: size_t): Size
        +get_l2_bank_capacity(bank_id: size_t): Size
        +run_matmul_test(test: MatMulTest, ...): bool
        +get_elapsed_time_ms(): double
        +print_stats(): void
        +print_component_status(): void
        +is_memory_bank_ready(bank_id: size_t): bool
        +is_scratchpad_ready(pad_id: size_t): bool
        +is_l3_tile_ready(tile_id: size_t): bool
        +is_l2_bank_ready(bank_id: size_t): bool
        -validate_bank_id(bank_id: size_t): void
        -validate_scratchpad_id(pad_id: size_t): void
        -validate_dma_id(dma_id: size_t): void
        -validate_tile_id(tile_id: size_t): void
        -validate_l3_tile_id(tile_id: size_t): void
        -validate_l2_bank_id(bank_id: size_t): void
        -validate_block_mover_id(mover_id: size_t): void
    }

    class Config {
        +memory_bank_count: size_t
        +memory_bank_capacity_mb: size_t
        +memory_bandwidth_gbps: double
        +scratchpad_count: size_t
        +scratchpad_capacity_kb: size_t
        +compute_tile_count: size_t
        +dma_engine_count: size_t
        +l3_tile_count: size_t
        +l3_tile_capacity_kb: size_t
        +l2_bank_count: size_t
        +l2_bank_capacity_kb: size_t
        +block_mover_count: size_t
    }

    class MatMulTest {
        +m: Size
        +n: Size
        +k: Size
        +matrix_a: vector~float~
        +matrix_b: vector~float~
        +expected_c: vector~float~
    }

    class MemoryBank {
        +MemoryBank(capacity_mb: size_t, bandwidth_gbps: double)
        +read(addr: Address, data: void*, size: Size): void
        +write(addr: Address, data: void*, size: Size): void
        +get_capacity(): Size
        +is_ready(): bool
        +reset(): void
    }

    class Scratchpad {
        +Scratchpad(capacity_kb: size_t)
        +read(addr: Address, data: void*, size: Size): void
        +write(addr: Address, data: void*, size: Size): void
        +get_capacity(): Size
        +is_ready(): bool
        +reset(): void
    }

    class ComputeTile {
        +ComputeTile(tile_id: size_t)
        +start_matmul(config: MatMulConfig): void
        +is_busy(): bool
        +update(cycle: uint64_t, scratchpads: vector~Scratchpad~&): void
        +reset(): void
    }

    class DMAEngine {
        <<enumeration>> MemoryType
        EXTERNAL
        SCRATCHPAD
        L3_TILE
        L2_BANK
        
        +DMAEngine(engine_id: size_t)
        +enqueue_transfer(...): void
        +is_busy(): bool
        +get_queue_size(): size_t
        +process_transfers(...): void
        +reset(): void
    }

    class L3Tile {
        +L3Tile(tile_id: size_t, capacity_kb: size_t)
        +read(addr: Address, data: void*, size: Size): void
        +write(addr: Address, data: void*, size: Size): void
        +get_capacity(): Size
        +is_ready(): bool
        +reset(): void
    }

    class L2Bank {
        +L2Bank(bank_id: size_t, capacity_kb: size_t)
        +read(addr: Address, data: void*, size: Size): void
        +write(addr: Address, data: void*, size: Size): void
        +get_capacity(): Size
        +is_ready(): bool
        +reset(): void
    }

    class BlockMover {
        <<enumeration>> TransformType
        
        +BlockMover(mover_id: size_t, associated_l3_tile: size_t)
        +enqueue_block_transfer(...): void
        +is_busy(): bool
        +get_queue_size(): size_t
        +get_associated_l3_tile(): size_t
        +process_transfers(l3_tiles: vector~L3Tile~&, l2_banks: vector~L2Bank~&): void
        +reset(): void
    }

    class MatMulConfig {
        +m: Size
        +n: Size
        +k: Size
        +a_addr: Address
        +b_addr: Address
        +c_addr: Address
        +scratchpad_id: size_t
        +completion_callback: function~void()~
    }

    %% Relationships
    KPUSimulator *-- Config : uses
    KPUSimulator *-- MatMulTest : uses
    KPUSimulator "1" *-- "many" MemoryBank : contains
    KPUSimulator "1" *-- "many" Scratchpad : contains
    KPUSimulator "1" *-- "many" ComputeTile : contains
    KPUSimulator "1" *-- "many" DMAEngine : contains
    KPUSimulator "1" *-- "many" L3Tile : contains
    KPUSimulator "1" *-- "many" L2Bank : contains
    KPUSimulator "1" *-- "many" BlockMover : contains
    ComputeTile ..> MatMulConfig : uses
    DMAEngine ..> MemoryBank : accesses
    DMAEngine ..> Scratchpad : accesses
    BlockMover ..> L3Tile : accesses
    BlockMover ..> L2Bank : accesses

    %% Namespace
    namespace sw_kpu {
        class KPUSimulator
        class Config
        class MatMulTest
        class MemoryBank
        class Scratchpad
        class ComputeTile
        class DMAEngine
        class L3Tile
        class L2Bank
        class BlockMover
        class MatMulConfig
    }
```
