#!/usr/bin/env python3
"""
Visualize L3 Cache Overfetch Analysis

This script reads CSV files generated by the L3 overfetch analyzer and
creates visualizations showing how L3 cache size affects DRAM traffic.

The KEY INSIGHT:
- Small L3 → High overfetch (tiles evicted and reloaded from DRAM)
- Large L3 → Low overfetch (tiles stay resident)
- KNEE OF CURVE → Optimal L3 size (diminishing returns beyond)

Usage:
    python visualize_l3_overfetch.py l3_overfetch_512x512x512.csv
"""

import sys
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from pathlib import Path

def find_knee_point(x, y):
    """
    Find the knee of the curve using the maximum distance method.

    The knee is the point where the improvement in overfetch starts
    to diminish significantly.
    """
    # Normalize data to [0, 1]
    x_norm = (x - x.min()) / (x.max() - x.min())
    y_norm = (y - y.min()) / (y.max() - y.min())

    # Line from first to last point
    p1 = np.array([x_norm.iloc[0], y_norm.iloc[0]])
    p2 = np.array([x_norm.iloc[-1], y_norm.iloc[-1]])

    # Calculate perpendicular distance from each point to the line
    distances = []
    for i in range(len(x_norm)):
        p = np.array([x_norm.iloc[i], y_norm.iloc[i]])
        d = np.abs(np.cross(p2 - p1, p1 - p)) / np.linalg.norm(p2 - p1)
        distances.append(d)

    # Knee is the point with maximum distance
    knee_idx = np.argmax(distances)
    return knee_idx

def plot_overfetch_analysis(csv_file, output_prefix=None):
    """Plot L3 overfetch analysis from CSV file"""

    # Read data
    df = pd.read_csv(csv_file)

    if output_prefix is None:
        output_prefix = Path(csv_file).stem

    # Create figure with 2x2 subplots
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle(f'L3 Cache Overfetch Analysis: {Path(csv_file).name}',
                 fontsize=16, fontweight='bold')

    # Find knee point
    knee_idx = find_knee_point(df['L3_Size_MB'], df['Overfetch_Total'])
    knee_l3_size = df['L3_Size_MB'].iloc[knee_idx]
    knee_overfetch = df['Overfetch_Total'].iloc[knee_idx]

    # ========================================================================
    # Plot 1: L3 Size vs Total Overfetch (THE MAIN PLOT - SHOWS THE KNEE)
    # ========================================================================
    ax = axes[0, 0]

    # Plot the curve
    ax.plot(df['L3_Size_MB'], df['Overfetch_Total'], 'o-',
            linewidth=3, markersize=10, color='#2E86AB', label='Overfetch Factor')

    # Highlight the knee point
    ax.plot(knee_l3_size, knee_overfetch, 'r*',
            markersize=20, label=f'Knee: {knee_l3_size:.0f} MB', zorder=10)

    # Add horizontal line at overfetch = 1.0 (ideal)
    ax.axhline(y=1.0, color='green', linestyle='--', alpha=0.5,
               linewidth=2, label='Ideal (no overfetch)')

    # Shade the region below the knee (good L3 sizes)
    ax.axvspan(0, knee_l3_size, alpha=0.1, color='green',
               label=f'Sweet spot: ≤{knee_l3_size:.0f} MB')

    # Shade the region after diminishing returns
    ax.axvspan(knee_l3_size, df['L3_Size_MB'].max(), alpha=0.1, color='orange',
               label='Diminishing returns')

    ax.set_xlabel('L3 Cache Size (MB)', fontsize=14, fontweight='bold')
    ax.set_ylabel('Total Overfetch Factor', fontsize=14, fontweight='bold')
    ax.set_title('L3 Size vs DRAM Overfetch\n(KNEE OF THE CURVE)',
                 fontsize=14, fontweight='bold')
    ax.grid(True, alpha=0.3, linestyle=':')
    ax.legend(loc='upper right', fontsize=10)

    # Set log scale for x-axis to better show the knee
    ax.set_xscale('log', base=2)
    ax.set_xticks(df['L3_Size_MB'])
    ax.get_xaxis().set_major_formatter(plt.ScalarFormatter())

    # Add annotation explaining the knee
    ax.annotate(
        f'Beyond {knee_l3_size:.0f}MB:\nDiminishing returns',
        xy=(knee_l3_size, knee_overfetch),
        xytext=(knee_l3_size * 2, knee_overfetch + 0.5),
        arrowprops=dict(arrowstyle='->', color='red', lw=2),
        fontsize=11, fontweight='bold',
        bbox=dict(boxstyle='round,pad=0.5', facecolor='yellow', alpha=0.7)
    )

    # ========================================================================
    # Plot 2: L3 Size vs Hit Rate
    # ========================================================================
    ax = axes[0, 1]

    ax.plot(df['L3_Size_MB'], df['L3_Hit_Rate'] * 100, 's-',
            linewidth=3, markersize=10, color='#A23B72', label='L3 Hit Rate')

    # Highlight knee
    knee_hit_rate = df['L3_Hit_Rate'].iloc[knee_idx] * 100
    ax.plot(knee_l3_size, knee_hit_rate, 'r*',
            markersize=20, label=f'Knee: {knee_l3_size:.0f} MB', zorder=10)

    # Add horizontal line at 80% (good hit rate threshold)
    ax.axhline(y=80, color='green', linestyle='--', alpha=0.5,
               linewidth=2, label='80% threshold')

    ax.set_xlabel('L3 Cache Size (MB)', fontsize=14, fontweight='bold')
    ax.set_ylabel('L3 Hit Rate (%)', fontsize=14, fontweight='bold')
    ax.set_title('L3 Size vs Hit Rate', fontsize=14, fontweight='bold')
    ax.set_ylim([0, 105])
    ax.grid(True, alpha=0.3, linestyle=':')
    ax.legend(loc='lower right', fontsize=10)
    ax.set_xscale('log', base=2)
    ax.set_xticks(df['L3_Size_MB'])
    ax.get_xaxis().set_major_formatter(plt.ScalarFormatter())

    # ========================================================================
    # Plot 3: L3 Size vs DRAM Reads (Absolute Traffic)
    # ========================================================================
    ax = axes[1, 0]

    # Plot DRAM reads
    ax.plot(df['L3_Size_MB'], df['DRAM_Reads_KB'], 'o-',
            linewidth=3, markersize=10, color='#F18F01', label='DRAM Reads')

    # Add ideal line (minimum possible)
    ideal_dram = df['Tensor_A_KB'].iloc[0] + df['Tensor_B_KB'].iloc[0] + df['Tensor_C_KB'].iloc[0]
    ax.axhline(y=ideal_dram, color='green', linestyle='--', alpha=0.5,
               linewidth=2, label=f'Ideal: {ideal_dram:.0f} KB')

    # Highlight knee
    knee_dram = df['DRAM_Reads_KB'].iloc[knee_idx]
    ax.plot(knee_l3_size, knee_dram, 'r*',
            markersize=20, label=f'Knee: {knee_l3_size:.0f} MB', zorder=10)

    ax.set_xlabel('L3 Cache Size (MB)', fontsize=14, fontweight='bold')
    ax.set_ylabel('DRAM Read Traffic (KB)', fontsize=14, fontweight='bold')
    ax.set_title('L3 Size vs DRAM Traffic\n(Absolute Bytes)', fontsize=14, fontweight='bold')
    ax.grid(True, alpha=0.3, linestyle=':')
    ax.legend(loc='upper right', fontsize=10)
    ax.set_xscale('log', base=2)
    ax.set_xticks(df['L3_Size_MB'])
    ax.get_xaxis().set_major_formatter(plt.ScalarFormatter())

    # ========================================================================
    # Plot 4: Per-Tensor Overfetch Breakdown
    # ========================================================================
    ax = axes[1, 1]

    # Stack plot showing overfetch per tensor
    x = df['L3_Size_MB']
    width = 0.25
    x_pos = np.arange(len(x))

    ax.bar(x_pos - width, df['Overfetch_A'], width,
           label='Tensor A', color='#E63946', alpha=0.8)
    ax.bar(x_pos, df['Overfetch_B'], width,
           label='Tensor B', color='#457B9D', alpha=0.8)
    ax.bar(x_pos + width, df['Overfetch_C'], width,
           label='Tensor C', color='#2A9D8F', alpha=0.8)

    # Add horizontal line at 1.0
    ax.axhline(y=1.0, color='green', linestyle='--', alpha=0.5,
               linewidth=2, label='Ideal (1.0×)')

    # Highlight knee
    ax.axvline(x=knee_idx, color='red', linestyle=':', alpha=0.5, linewidth=2)

    ax.set_xlabel('L3 Cache Size (MB)', fontsize=14, fontweight='bold')
    ax.set_ylabel('Overfetch Factor', fontsize=14, fontweight='bold')
    ax.set_title('Per-Tensor Overfetch Breakdown', fontsize=14, fontweight='bold')
    ax.set_xticks(x_pos)
    ax.set_xticklabels(df['L3_Size_MB'].astype(int))
    ax.grid(True, alpha=0.3, linestyle=':', axis='y')
    ax.legend(loc='upper right', fontsize=10)

    plt.tight_layout()

    # Save figure
    output_file = f'{output_prefix}_visualization.png'
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f'Saved visualization to {output_file}')

    # Show if interactive
    if sys.stdout.isatty():
        plt.show()

    return fig, knee_idx

def print_statistics(csv_file):
    """Print statistics about L3 overfetch"""

    df = pd.read_csv(csv_file)

    # Find knee
    knee_idx = find_knee_point(df['L3_Size_MB'], df['Overfetch_Total'])
    knee_l3_size = df['L3_Size_MB'].iloc[knee_idx]

    print(f"\n{'='*70}")
    print(f"L3 Overfetch Analysis: {Path(csv_file).name}")
    print(f"{'='*70}\n")

    print(f"Workload tensor sizes:")
    print(f"  Tensor A: {df['Tensor_A_KB'].iloc[0]:8.0f} KB")
    print(f"  Tensor B: {df['Tensor_B_KB'].iloc[0]:8.0f} KB")
    print(f"  Tensor C: {df['Tensor_C_KB'].iloc[0]:8.0f} KB")
    print(f"  Total:    {df['Tensor_A_KB'].iloc[0] + df['Tensor_B_KB'].iloc[0] + df['Tensor_C_KB'].iloc[0]:8.0f} KB")

    print(f"\nL3 cache sizes explored: {len(df)}")
    print(f"  Range: {df['L3_Size_MB'].min():.0f} MB to {df['L3_Size_MB'].max():.0f} MB")

    print(f"\n{'='*70}")
    print(f"KNEE OF THE CURVE: {knee_l3_size:.0f} MB L3")
    print(f"{'='*70}")
    print(f"  Overfetch at knee: {df['Overfetch_Total'].iloc[knee_idx]:.2f}×")
    print(f"  Hit rate at knee:  {df['L3_Hit_Rate'].iloc[knee_idx] * 100:.1f}%")
    print(f"  DRAM reads:        {df['DRAM_Reads_KB'].iloc[knee_idx]:.0f} KB")
    print(f"  L3 utilization:    {df['L3_Utilization'].iloc[knee_idx] * 100:.1f}%")

    print(f"\nOverfetch Factor Range:")
    print(f"  Minimum: {df['Overfetch_Total'].min():.2f}× @ {df.loc[df['Overfetch_Total'].idxmin(), 'L3_Size_MB']:.0f} MB")
    print(f"  Maximum: {df['Overfetch_Total'].max():.2f}× @ {df.loc[df['Overfetch_Total'].idxmax(), 'L3_Size_MB']:.0f} MB")
    print(f"  Improvement: {df['Overfetch_Total'].max() / df['Overfetch_Total'].min():.2f}× reduction")

    print(f"\nDRAM Read Traffic:")
    print(f"  Minimum: {df['DRAM_Reads_KB'].min():8.0f} KB @ {df.loc[df['DRAM_Reads_KB'].idxmin(), 'L3_Size_MB']:.0f} MB")
    print(f"  Maximum: {df['DRAM_Reads_KB'].max():8.0f} KB @ {df.loc[df['DRAM_Reads_KB'].idxmax(), 'L3_Size_MB']:.0f} MB")

    ideal_dram = df['Tensor_A_KB'].iloc[0] + df['Tensor_B_KB'].iloc[0] + df['Tensor_C_KB'].iloc[0]
    print(f"  Ideal:   {ideal_dram:8.0f} KB (load each tensor once)")
    print(f"  Overhead at knee: {(df['DRAM_Reads_KB'].iloc[knee_idx] - ideal_dram) / ideal_dram * 100:.1f}%")

    print(f"\nL3 Hit Rate:")
    print(f"  Minimum: {df['L3_Hit_Rate'].min() * 100:5.1f}% @ {df.loc[df['L3_Hit_Rate'].idxmin(), 'L3_Size_MB']:.0f} MB")
    print(f"  Maximum: {df['L3_Hit_Rate'].max() * 100:5.1f}% @ {df.loc[df['L3_Hit_Rate'].idxmax(), 'L3_Size_MB']:.0f} MB")
    print(f"  At knee: {df['L3_Hit_Rate'].iloc[knee_idx] * 100:5.1f}%")

    print()

def print_recommendations(csv_file):
    """Print design recommendations"""

    df = pd.read_csv(csv_file)
    knee_idx = find_knee_point(df['L3_Size_MB'], df['Overfetch_Total'])
    knee_l3_size = df['L3_Size_MB'].iloc[knee_idx]

    print(f"\n{'='*70}")
    print(f"Design Recommendations")
    print(f"{'='*70}\n")

    print(f"RECOMMENDED L3 SIZE: {knee_l3_size:.0f} MB")
    print(f"  Reasoning:")
    print(f"    - Overfetch: {df['Overfetch_Total'].iloc[knee_idx]:.2f}× (close to ideal)")
    print(f"    - Hit rate: {df['L3_Hit_Rate'].iloc[knee_idx] * 100:.1f}% (good)")
    print(f"    - Beyond this: Diminishing returns")

    # Compare smallest vs knee
    print(f"\nTRADEOFF ANALYSIS:")
    smallest_idx = 0
    largest_idx = len(df) - 1

    print(f"\n  Smallest L3 ({df['L3_Size_MB'].iloc[smallest_idx]:.0f} MB):")
    print(f"    Overfetch:  {df['Overfetch_Total'].iloc[smallest_idx]:.2f}×")
    print(f"    Hit rate:   {df['L3_Hit_Rate'].iloc[smallest_idx] * 100:.1f}%")
    print(f"    DRAM reads: {df['DRAM_Reads_KB'].iloc[smallest_idx]:.0f} KB")

    print(f"\n  Knee ({knee_l3_size:.0f} MB):")
    print(f"    Overfetch:  {df['Overfetch_Total'].iloc[knee_idx]:.2f}×")
    print(f"    Hit rate:   {df['L3_Hit_Rate'].iloc[knee_idx] * 100:.1f}%")
    print(f"    DRAM reads: {df['DRAM_Reads_KB'].iloc[knee_idx]:.0f} KB")
    print(f"    Improvement: {df['Overfetch_Total'].iloc[smallest_idx] / df['Overfetch_Total'].iloc[knee_idx]:.2f}× lower overfetch")
    print(f"    Cost: {knee_l3_size / df['L3_Size_MB'].iloc[smallest_idx]:.0f}× more L3 cache")

    print(f"\n  Largest L3 ({df['L3_Size_MB'].iloc[largest_idx]:.0f} MB):")
    print(f"    Overfetch:  {df['Overfetch_Total'].iloc[largest_idx]:.2f}×")
    print(f"    Hit rate:   {df['L3_Hit_Rate'].iloc[largest_idx] * 100:.1f}%")
    print(f"    DRAM reads: {df['DRAM_Reads_KB'].iloc[largest_idx]:.0f} KB")
    print(f"    Improvement over knee: {df['Overfetch_Total'].iloc[knee_idx] / df['Overfetch_Total'].iloc[largest_idx]:.2f}× (marginal!)")
    print(f"    Cost: {df['L3_Size_MB'].iloc[largest_idx] / knee_l3_size:.0f}× more L3 cache than knee")

    print(f"\nKEY INSIGHT:")
    print(f"  The knee at {knee_l3_size:.0f} MB gives you most of the benefit.")
    print(f"  Going larger provides minimal overfetch improvement but costs much more area.")

    print()

def main():
    if len(sys.argv) < 2:
        print("Usage: python visualize_l3_overfetch.py <csv_file>")
        print("\nExample:")
        print("  python visualize_l3_overfetch.py l3_overfetch_512x512x512.csv")
        sys.exit(1)

    csv_file = sys.argv[1]

    if not Path(csv_file).exists():
        print(f"Error: File '{csv_file}' not found")
        sys.exit(1)

    # Print statistics
    print_statistics(csv_file)

    # Print recommendations
    print_recommendations(csv_file)

    # Create visualizations
    plot_overfetch_analysis(csv_file)

if __name__ == '__main__':
    main()
