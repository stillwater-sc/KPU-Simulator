#!/usr/bin/env python3
"""
Visualize Hardware Design Space Exploration Results

This script reads CSV files generated by the hardware design explorer and
creates visualizations showing the impact of L2 cache size on energy, latency,
and hardware cost.

The FUNDAMENTAL HARDWARE DESIGN TRADEOFF:
- Larger L2 → Lower energy (better reuse) but higher hardware cost
- Smaller L2 → Higher energy (poor reuse) but lower hardware cost

Usage:
    python visualize_hardware_design_space.py hardware_design_space.csv
"""

import sys
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from pathlib import Path

def plot_design_space(csv_file, output_prefix=None):
    """Plot hardware design space from CSV file"""

    # Read data
    df = pd.read_csv(csv_file)

    if output_prefix is None:
        output_prefix = Path(csv_file).stem

    # Create figure with multiple subplots
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    fig.suptitle(f'Hardware Design Space Exploration: {Path(csv_file).name}',
                 fontsize=16, fontweight='bold')

    # 1. L2 Size vs Average Energy (THE FUNDAMENTAL TRADEOFF)
    ax = axes[0, 0]
    ax.plot(df['L2_Size_KB'], df['Avg_Energy_pJ'], 'o-', linewidth=2, markersize=8, color='blue')
    ax.set_xlabel('L2 Cache Size (KB)', fontsize=12)
    ax.set_ylabel('Average Energy (pJ)', fontsize=12)
    ax.set_title('L2 Cache Size vs Energy')
    ax.grid(True, alpha=0.3)

    # Add annotation explaining the tradeoff
    ax.text(0.05, 0.95, 'Larger L2 → Lower energy\n(Better data reuse, fewer DRAM fetches)',
            transform=ax.transAxes, fontsize=9, verticalalignment='top',
            bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.5))

    # Highlight optimal point (minimum energy)
    min_energy_idx = df['Avg_Energy_pJ'].idxmin()
    ax.plot(df.loc[min_energy_idx, 'L2_Size_KB'],
            df.loc[min_energy_idx, 'Avg_Energy_pJ'],
            'r*', markersize=15, label=f"Optimal: {df.loc[min_energy_idx, 'L2_Size_KB']:.0f} KB")
    ax.legend()

    # 2. L2 Size vs Average Latency
    ax = axes[0, 1]
    ax.plot(df['L2_Size_KB'], df['Avg_Latency_cycles'], 'o-', linewidth=2, markersize=8, color='green')
    ax.set_xlabel('L2 Cache Size (KB)', fontsize=12)
    ax.set_ylabel('Average Latency (cycles)', fontsize=12)
    ax.set_title('L2 Cache Size vs Latency')
    ax.grid(True, alpha=0.3)

    # Highlight optimal point (minimum latency)
    min_latency_idx = df['Avg_Latency_cycles'].idxmin()
    ax.plot(df.loc[min_latency_idx, 'L2_Size_KB'],
            df.loc[min_latency_idx, 'Avg_Latency_cycles'],
            'r*', markersize=15, label=f"Optimal: {df.loc[min_latency_idx, 'L2_Size_KB']:.0f} KB")
    ax.legend()

    # 3. Hardware Cost vs Energy (Cost-Energy Tradeoff)
    ax = axes[1, 0]
    ax.plot(df['Hardware_Cost'], df['Avg_Energy_pJ'], 'o-', linewidth=2, markersize=8, color='red')

    # Annotate each point with L2 size
    for i, row in df.iterrows():
        ax.annotate(f"{row['L2_Size_KB']:.0f}KB",
                   (row['Hardware_Cost'], row['Avg_Energy_pJ']),
                   textcoords="offset points", xytext=(0, 10),
                   ha='center', fontsize=8)

    ax.set_xlabel('Hardware Cost (normalized to 64KB = 1.0)', fontsize=12)
    ax.set_ylabel('Average Energy (pJ)', fontsize=12)
    ax.set_title('Hardware Cost vs Energy Tradeoff')
    ax.grid(True, alpha=0.3)

    # Add annotation
    ax.text(0.05, 0.95, 'Lower-left corner is ideal\n(Low cost, low energy)',
            transform=ax.transAxes, fontsize=9, verticalalignment='top',
            bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

    # 4. L2 Size vs Coverage and Efficiency
    ax = axes[1, 1]

    # Dual y-axis
    ax2 = ax.twinx()

    line1 = ax.plot(df['L2_Size_KB'], df['Coverage_Pct'], 'o-',
                   linewidth=2, markersize=8, color='purple', label='Workload Coverage (%)')
    line2 = ax2.plot(df['L2_Size_KB'], df['Avg_Utilization'] * 100, 's-',
                    linewidth=2, markersize=8, color='orange', label='PE Utilization (%)')

    ax.set_xlabel('L2 Cache Size (KB)', fontsize=12)
    ax.set_ylabel('Workload Coverage (%)', fontsize=12, color='purple')
    ax2.set_ylabel('Average PE Utilization (%)', fontsize=12, color='orange')
    ax.set_title('L2 Size vs Coverage and Utilization')
    ax.tick_params(axis='y', labelcolor='purple')
    ax2.tick_params(axis='y', labelcolor='orange')
    ax.grid(True, alpha=0.3)

    # Combine legends
    lines = line1 + line2
    labels = [l.get_label() for l in lines]
    ax.legend(lines, labels, loc='best')

    plt.tight_layout()

    # Save figure
    output_file = f'{output_prefix}_visualization.png'
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f'Saved visualization to {output_file}')

    # Show if interactive
    if sys.stdout.isatty():
        plt.show()

    return fig

def print_statistics(csv_file):
    """Print statistics about the hardware design space"""

    df = pd.read_csv(csv_file)

    print(f"\n{'='*70}")
    print(f"Hardware Design Space Statistics: {Path(csv_file).name}")
    print(f"{'='*70}\n")

    print(f"L2 cache sizes explored: {len(df)}")
    print(f"  Range: {df['L2_Size_KB'].min():.0f} KB to {df['L2_Size_KB'].max():.0f} KB")
    print(f"  Workloads per configuration: {df['Num_Workloads'].iloc[0]}")

    print(f"\nEnergy Results:")
    print(f"  Minimum average energy: {df['Avg_Energy_pJ'].min():.2e} pJ")
    print(f"    @ L2 size: {df.loc[df['Avg_Energy_pJ'].idxmin(), 'L2_Size_KB']:.0f} KB")
    print(f"  Maximum average energy: {df['Avg_Energy_pJ'].max():.2e} pJ")
    print(f"    @ L2 size: {df.loc[df['Avg_Energy_pJ'].idxmax(), 'L2_Size_KB']:.0f} KB")
    print(f"  Energy reduction (min vs max): {df['Avg_Energy_pJ'].max() / df['Avg_Energy_pJ'].min():.2f}×")

    print(f"\nLatency Results:")
    print(f"  Minimum average latency: {df['Avg_Latency_cycles'].min():.0f} cycles")
    print(f"    @ L2 size: {df.loc[df['Avg_Latency_cycles'].idxmin(), 'L2_Size_KB']:.0f} KB")
    print(f"  Maximum average latency: {df['Avg_Latency_cycles'].max():.0f} cycles")
    print(f"    @ L2 size: {df.loc[df['Avg_Latency_cycles'].idxmax(), 'L2_Size_KB']:.0f} KB")

    print(f"\nHardware Cost:")
    print(f"  Minimum cost: {df['Hardware_Cost'].min():.2f}× (baseline)")
    print(f"    @ L2 size: {df.loc[df['Hardware_Cost'].idxmin(), 'L2_Size_KB']:.0f} KB")
    print(f"  Maximum cost: {df['Hardware_Cost'].max():.2f}× (baseline)")
    print(f"    @ L2 size: {df.loc[df['Hardware_Cost'].idxmax(), 'L2_Size_KB']:.0f} KB")

    print(f"\nCoverage:")
    print(f"  Minimum coverage: {df['Coverage_Pct'].min():.1f}%")
    print(f"    @ L2 size: {df.loc[df['Coverage_Pct'].idxmin(), 'L2_Size_KB']:.0f} KB")
    print(f"  Maximum coverage: {df['Coverage_Pct'].max():.1f}%")
    print(f"    @ L2 size: {df.loc[df['Coverage_Pct'].idxmax(), 'L2_Size_KB']:.0f} KB")

    # Find best energy/cost ratio
    best_ratio_idx = df['Energy_Per_Cost'].idxmin()
    print(f"\nBest Energy/Cost Configuration:")
    print(f"  L2 size: {df.loc[best_ratio_idx, 'L2_Size_KB']:.0f} KB")
    print(f"  Hardware cost: {df.loc[best_ratio_idx, 'Hardware_Cost']:.2f}×")
    print(f"  Average energy: {df.loc[best_ratio_idx, 'Avg_Energy_pJ']:.2e} pJ")
    print(f"  Energy/Cost ratio: {df.loc[best_ratio_idx, 'Energy_Per_Cost']:.2e}")

    print()

def print_recommendations(csv_file):
    """Print design recommendations based on analysis"""

    df = pd.read_csv(csv_file)

    print(f"\n{'='*70}")
    print(f"Design Recommendations")
    print(f"{'='*70}\n")

    # Energy-optimized design
    min_energy_idx = df['Avg_Energy_pJ'].idxmin()
    print(f"For MINIMUM ENERGY:")
    print(f"  L2 size: {df.loc[min_energy_idx, 'L2_Size_KB']:.0f} KB")
    print(f"  Hardware cost: {df.loc[min_energy_idx, 'Hardware_Cost']:.2f}×")
    print(f"  Average energy: {df.loc[min_energy_idx, 'Avg_Energy_pJ']:.2e} pJ")
    print(f"  Coverage: {df.loc[min_energy_idx, 'Coverage_Pct']:.1f}%")

    # Cost-optimized design
    min_cost_idx = df['Hardware_Cost'].idxmin()
    print(f"\nFor MINIMUM COST:")
    print(f"  L2 size: {df.loc[min_cost_idx, 'L2_Size_KB']:.0f} KB")
    print(f"  Hardware cost: {df.loc[min_cost_idx, 'Hardware_Cost']:.2f}×")
    print(f"  Average energy: {df.loc[min_cost_idx, 'Avg_Energy_pJ']:.2e} pJ")
    print(f"  Energy penalty vs optimal: {df.loc[min_cost_idx, 'Avg_Energy_pJ'] / df.loc[min_energy_idx, 'Avg_Energy_pJ']:.2f}×")

    # Balanced design (best energy/cost)
    best_ratio_idx = df['Energy_Per_Cost'].idxmin()
    print(f"\nFor BEST ENERGY/COST BALANCE:")
    print(f"  L2 size: {df.loc[best_ratio_idx, 'L2_Size_KB']:.0f} KB")
    print(f"  Hardware cost: {df.loc[best_ratio_idx, 'Hardware_Cost']:.2f}×")
    print(f"  Average energy: {df.loc[best_ratio_idx, 'Avg_Energy_pJ']:.2e} pJ")
    print(f"  Coverage: {df.loc[best_ratio_idx, 'Coverage_Pct']:.1f}%")

    print()

def main():
    if len(sys.argv) < 2:
        print("Usage: python visualize_hardware_design_space.py <csv_file>")
        print("\nExample:")
        print("  python visualize_hardware_design_space.py hardware_design_space.csv")
        sys.exit(1)

    csv_file = sys.argv[1]

    if not Path(csv_file).exists():
        print(f"Error: File '{csv_file}' not found")
        sys.exit(1)

    # Print statistics
    print_statistics(csv_file)

    # Print recommendations
    print_recommendations(csv_file)

    # Create visualizations
    plot_design_space(csv_file)

if __name__ == '__main__':
    main()
